# Intermediate Code Generator & Simulator

This repository contains an intermediate code generator and simulator for a specific Instruction Set Architecture (ISA). The code generator takes a specific input format and generates intermediate code, while the simulator executes the generated code.

## üìù Intermediate Code Generator

The intermediate code generator is implemented in Python. It takes a specific input format from the standard input (stdin) and generates intermediate code as output. The generated code can be used as input for the simulator.

### ‚å®Ô∏è Input Format
The input format for the code generator follows specific rules:
- Instructions should be space-separated.
- The last element of every line should be a newline character '\n'.
- The program supports various types of instructions, including arithmetic instructions, register-shift instructions, move instructions, load instructions, store instructions, division instructions, not instructions, comparison instructions, jump instructions, halt instructions, variable definitions, and label definitions. 

### üöÄ Usage
1. Prepare a text file containing the input instructions in the specified format.
2. Run the code generator program in the terminal or command prompt: <br>
    - python code_generator.py < input.txt <br>
Replace `code_generator.py` with the actual filename of the program, and `input.txt` with the filename of your input file.
3. The program will generate the intermediate code as output.

## üíª Simulator

The simulator is implemented as a separate component. It takes a binary file (in the same format as generated by the code generator) as input and executes the code. The simulator loads the binary into system memory, starts executing the code from address 0, and continues until the "hlt" instruction is reached.

### üß© Components
The simulator consists of the following distinct components:

1. Memory (MEM): The memory component stores 512 bytes of data. It takes an 8-bit address and returns a 16-bit value as the data.

2. Program Counter (PC): The program counter is an 8-bit register that points to the current instruction.

3. Register File (RF): The register file component takes the register name (R0, R1, ..., R6, or FLAGS) and returns the value stored in that register.

4. Execution Engine (EE): The execution engine component takes the address of the instruction from the program counter, retrieves the instruction from memory, and executes it by updating the register file and program counter.

### üöÄ Usage
1. Prepare a binary file using the intermediate code generated by the code generator.
2. Run the simulator program in the terminal or command prompt: <br>
  - python simulator.py < binary_file.bin <br>
Replace `simulator.py` with the actual filename of the simulator program, and `binary_file.bin` with the filename of your binary file.
3. The simulator will load the binary into memory and start executing the code.
4. After each instruction, the simulator will output one line containing the program counter and the values of the registers (R0, R1, ..., R6, and FLAGS).
5. Once the program is halted, the simulator will print the memory dump of the entire memory, consisting of 256 lines with 16-bit values.

## üåü Example
To understand the input format, code generation, and simulation, you can refer to the provided example files (`input.txt` for the code generator and `binary_file.bin` for the simulator).

Feel free to explore and modify the code generator and simulator according to your requirements. If you encounter any issues or have suggestions for improvement, please don't hesitate to open an issue or submit a pull request.

